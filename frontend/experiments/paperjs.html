<!DOCTYPE html>
<html>
<head>
<!-- Load the Paper.js library -->
<script type="text/javascript" src="js/paper.js"></script>

<style type="text/css">
#myCanvas {
  border: 1px solid blue;
}
</style>

<!-- Define inlined PaperScript associate it with myCanvas -->
<script type="text/paperscript" canvas="myCanvas">
  var RObject = function(attributes) {
    this.animations   = []
    this.paper        = new Path.Circle({
      center:      attributes.center,
      radius:      30,
    })

    this.paper.fillColor = {
      gradient: {
        stops:  [
          ['white',   0.005],
          ['#AAAAFF', 0.4],
          ['#3333FF', 1],
        ],
        radial: true,
      },
      origin:      (this.paper.position + this.paper.bounds.leftCenter + this.paper.bounds.topCenter)/3,
      destination: this.paper.bounds.rightCenter,
    },

    this.isForeground = true
    if(!attributes.isForeground)
      this.toBackground()

    while(this.animations.length != 0)
      this.update()
  }

  RObject.prototype.update = function() {
    var animation = this.animations[0]
    if(animation && !animation(this.paper))
      this.animations.shift()
  }

  RObject.prototype.nAnimations = function(times, animation) {
    this.animations.push(function(paper) {
      if(times <= 0) return false
      animation(paper)
      times--
      return true
    })
  }

  RObject.prototype.toForeground = function() {
    if(this.isForeground) return
    this.isForeground = true
    this.nAnimations(20, function(paper) {
      paper.scale(100/95)
    })
  }

  RObject.prototype.toBackground = function() {
    if(!this.isForeground) return
    this.isForeground = false
    this.nAnimations(20, function(paper) {
      paper.scale(95/100)
    })
  }



  // Two circles, offset from the center
  var offset = [50, 0]

  var leftObject  = new RObject({
    isForeground: true,
    center: view.center - offset,
  })

  var rightObject = new RObject({
    isForeground: true,
    center: view.center + offset,
  })
  rightObject.toBackground()

	// A line connecting them
  var path = new Path({strokeColor: 'black'});
  path.moveTo(leftObject.paper.position)
  path.lineTo(rightObject.paper.position);

  function onFrame(event) {
    leftObject.update()
    rightObject.update()

    // event.count // the number of times the frame event was fired
    // event.time  // The total amount of time passed since the first frame event in seconds
    // event.delta // The time passed in seconds since the last frame event
  }

  function onKeyDown(event) {
    if(event.key == 'left') {
      leftObject.toForeground()
      rightObject.toBackground()
      return false; // Prevent the key event from bubbling

    } else if(event.key == 'right') {
      leftObject.toBackground()
      rightObject.toForeground()
      return false;
    }
  }


  // // Create a symbol, which we will use to place instances of later:
  // var path = new Path.Circle({
  //   center: [0, 0],
  //   radius: 10,
  //   fillColor: 'white',
  //   strokeColor: 'black'
  // });
  // var symbol = new Symbol(path);

  // // place the symbol
	// var center = Point.random() * view.size;
	// var placedSymbol = symbol.place(center);
	// placedSymbol.scale(i / count);

  // // some attributes we can access
  // item.position.x
  // item.bounds.width
  // item.bounds.left
  // view.size.width
</script>

</head>
<body>
	<canvas id="myCanvas" resize></canvas>
</body>
</html>
