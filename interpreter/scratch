Variations on current
code: ""
  evaluation 0
    current_expression: nil
    current_evaluation: Unevaluated(null)
    isFinished:         false

  evaluation 1
    current_expression: nil
    current_evaluation: Finished
    isFinished:         true

code: "1"
  evaluation 0
    current_expression: nil
    current_evaluation: Unevaluated(AstInteger(1))
    isFinished:         false

    Unevaluated(AstInteger(1))
    Evaluated(RFixnum(1))
    Finished

  evaluation 1
    current_expression: RFixnum(1)
    current_evaluation: Finished
    isFinished:         true

code: "1; 2"
  evaluation 0
    isFinished:         false
    current_expression: nil
    current_evaluation: Unevaluated(
                          AstExpressions([
                            AstInteger(1),
                            AstInteger(2)
                          ])
                        )
  evaluation 1
    isFinished:         false
    current_expression: RFixnum(1)
    current_evaluation:
        Unevaluated(
          AstExpressions([
            AstInteger(1),
            AstInteger(2)
          ]
        )

        EvalExpressions(
          Evaluated(RFixnum(1))
          EvalExpressions(
            Unevaluated(AstInteger(2))
            CurrentExpression
          )
        )

        EvalExpressions(
          Evaluated(RFixnum(2))
          CurrentExpression
        )

        CurrentExpression

        Finished

        -----

        Unevaluated(
          AstExpressions([
            AstInteger(1),
            AstInteger(2)
          ]
        )

        EvalExpressions(
          Evaluated(RFixnum(1))
          EvalExpressions(
            Unevaluated(AstInteger(2))
            CurrentExpression
          )
        )

        EvalExpressions(
          Evaluated(RFixnum(2))
          CurrentExpression
        )

        CurrentExpression

Or everything as a list: Do this, then move onto that thing
  ast(1; 2)
  exprs([ast(1), ast(2)])
  ast(1) -> exprs([ast(2)])
  done(fixnum(1)) -> exprs([ast(2)])
  exprs([ast(2)])
  ast(2) -> exprs([])
  done(fixnum(2)) -> exprs([])
  exprs([])
  returnCurrent


Or as ds that represent current algorithms
  AstExpressions(expressions=[AstFixnum(1), AstFixnum(2)])
  var result = null;
  for(expression in expressions) {
    result = eval(expression);
  }
  return result

  definition
  ExpressionList(result:EvaluationState, toEvaluate:Array<EvaluationState>)

  algorithm
  case ExpressionList(Evaluated(_), [next, rest]): return ExpressionList(next, rest);
  case ExpressionList(e=Evaluated(_), []): return e;
  case ExpressionList(toEvaluate, rest): return ExpressionList(eval(toEvaluate), rest);

Or as conjunction stack/data structure, always working on the top one, but can see pending expressions below
code: "A::B, 1+2";
AstExpressionList([
  AstConstant(name="B", Constant(name="A", null)),
  AstSend(target=AstInteger(1), message="+", args=[AstInteger(1)]
]);
