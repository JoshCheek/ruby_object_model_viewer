Machines
========

main:
  > The main machine, kicks everything else off
  /ast($ast)
  /ast/nil

emit: @value
  $currentBinding.returnValue <- @value
  $foundExpression <- $rTrue

reemit:
  $foundExpression <- $rTrue

newPrimitive: @class, @data
  > helper for builtin types with fancy data

  @object                   <- {}
  @object.class             <- @class
  @object.instanceVariables <- {}
  @object.primitiveData     <- @data

  /emit(@object)

ast: @ast
  > Interpreters for language constructs

  self <- /ast/@ast.type

  nil:
    /emit($rNil)

  false:
    /emit($rFalse)

  true:
    /emit($rTrue)

  string: @ast
    /newPrimitive($rString, @ast.value)

  expressions: @ast
    for @expression in @ast.expressions
      /ast(@expression)
    /reemit


Templates
=========

machines(root)
  export default () => {
    return {
      <%= machine root %>
    }
  }


machine(defn)
  <%- require 'json' -%>
  "name":         <%= defn.name.to_json %>,
  "description":  <%= defn.description.to_json %>,
  "namespace":    <%= defn.namespace.to_json %>,
  "arg_names":    <%= defn.arg_names.to_json %>,
  <%- if defn.instructions.length < 2 -%>
    "instructions": <%= defn.instructions.to_json %>,
  <%- else -%>
    "instructions": [
      <%= defn.instructions.map(&:to_json).join(",\n") %>
    ],
  <%- end -%>
  <%- if defn.children.empty? -%>
    "children":     {},
  <%- else -%>
    "children": {
      <%- defn.children.map do |name, child| -%>
        <%= child.name.to_json %>: {
          <%= machine child -%>
        },
      <%- end -%>
    },
  <%- end -%>

instructions(instructions)
  "use strict"

  export default {
    <%- instructions.each do |name, attrs| -%>
      <%= name %>: (world, state, machine, registers<%= attrs[:argnames].map { |a| ", #{a}" }.join %>) => {
        <%= attrs[:body] %>
      },

    <%- end -%>
  }



Instructions
============

setInt(register, initialValue)
  registers[register] = initialValue

add(register, quantity)
  if(typeof quantity !== 'number')
    throw(new Error(`Not a numeber! ${quantity}`))
  registers[register] += quantity

eq(toRegister, left, right)
  registers[toRegister] = (registers[left] == registers[right])

getKey(toRegister, hashRegister, key)
  if(key[0] === '@') key = registers[key]
  registers[toRegister] = registers[hashRegister][key]

globalToRegister(globalName, registerName)
  if(world[globalName] == undefined) throw(new Error(`No global ${globalName} in globalToRegister`))
  registers[registerName] = world[globalName]

jumpTo(label)
  machine.setInstructionPointer(state.labels[label])

jumpToIf(label, conditionRegister)
  if(registers[conditionRegister])
    machine.setInstructionPointer( state.labels[label])

label(name)
  /* noop */

registerToGlobal(registerName, globalName)
  let value = registers[registerName]
  world[globalName] = value

setKey(hashRegister, key, valueRegister)
  if(key[0] === '@') key = registers[key]
  registers[hashRegister][key] = registers[valueRegister]

becomeMachine(path)
  let newMachine = world.$rootMachine
  path.forEach((name) => {
    if(name[0] === "@")
      newMachine = newMachine.child(registers[name], machine.state.parent)
    else
      newMachine = newMachine.child(name, machine.state.parent)
  })
  newMachine.setArgsFromRegisters(registers)
  world.$machineStack = newMachine

runMachine(path, argNames)
  let newMachine = world.$rootMachine
  path.forEach((name) => {
    if(name[0] === "@")
      newMachine = newMachine.child(registers[name], machine)
    else
      newMachine = newMachine.child(name, machine)
  })
  let args = argNames.map((name) => registers[name])
  newMachine.setArgs(args)
  world.$machineStack = newMachine

newHash(register)
  registers[register] = {}

aryAppend(aryRegister, toAppendRegister)
  registers[aryRegister].push(registers[toAppendRegister])
