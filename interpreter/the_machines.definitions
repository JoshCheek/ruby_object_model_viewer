Machines
========

main:
  > The main machine, kicks everything else off
  /ast($ast)
  /ast/nil

emit: @value
  $bindingStack.returnValue <- @value
  $foundExpression <- $rTrue

reemit:
  $foundExpression <- $rTrue

newPrimitive: @class, @data
  > helper for builtin types with fancy data

  @object                   <- {}
  @object.class             <- @class
  @object.instanceVariables <- {}
  @object.primitiveData     <- @data

  /emit(@object)

ast: @ast
  > Interpreters for language constructs

  self <- /ast/@ast.type

  nil:
    /emit($rNil)

  false:
    /emit($rFalse)

  true:
    /emit($rTrue)

  self:
    /emit($bindingStack.self)

  string: @ast
    /newPrimitive($rString, @ast.value)

  expressions: @ast
    for @expression in @ast.expressions
      /ast(@expression)
    /reemit

  get_local_variable: @ast
    # { "type": "get_local_variable", "name": "a" }
    @locals  <- $bindingStack.localVariables
    @varName <- @ast.name
    @value   <- @locals[@varName]
    /emit(@value)

  set_local_variable: @ast
    # { "type": "set_local_variable", "name": "a", "value": { "type": "integer", "value": "1", } }
    @varName <- @ast.name
    @binding <- $bindingStack
    @locals  <- @binding.localVariables
    @locals[@varName] <- $rNil

    /ast(@ast.value)

    @value   <- @binding.returnValue
    @locals[@varName] <- @value

    /reemit

  constant: @ast
    # TODO: this is currently bs, there is an algorithm of how to do this (http://cirw.in/blog/constant-lookup.html)
    # { "type": "constant", "namespace": null, "name": "String", }
    @name      <- @ast.name
    @constants <- $toplevelNamespace.constants
    @constant  <- @constants[@name]
    /emit(@constant)

Templates
=========

machines(root)
  export default () => {
    return {
      <%= machine root %>
    }
  }


machine(defn)
  <%- require 'json' -%>
  "name":         <%= defn.name.to_json %>,
  "description":  <%= defn.description.to_json %>,
  "namespace":    <%= defn.namespace.to_json %>,
  "arg_names":    <%= defn.arg_names.to_json %>,
  "labels":       <%= defn.labels.to_json %>,
  <%- if defn.instructions.length < 2 -%>
    "instructions": <%= defn.instructions.to_json %>,
  <%- else -%>
    "instructions": [
      <%= defn.instructions.map(&:to_json).join(",\n") %>
    ],
  <%- end -%>
  <%- if defn.children.empty? -%>
    "children":     {},
  <%- else -%>
    "children": {
      <%- defn.children.map do |name, child| -%>
        <%= child.name.to_json %>: {
          <%= machine child -%>
        },
      <%- end -%>
    },
  <%- end -%>

instructions(instructions)
  "use strict"

  import {inspect} from 'util'

  let constructMachine = function(definition, parent) {
    return {
      definition         : definition,
      parent             : parent,
      registers          : {},
      instructionPointer : 0,
    }
  }

  let _newMachine = function (root, path, registers, parent) {
    let machineDef = root
    path.forEach((name) => {
      let registerName = (name[0] === '@' ? registers[name] :  name)
      machineDef = machineDef.children[registerName]
      if(!machineDef)
        throw (new Error(`No machine ${inspect(name)} -> ${inspect(registerName)} in ${inspect(path)}`))
    })
    return constructMachine(machineDef, parent)
  }

  export default {
    <%- instructions.each do |name, attrs| -%>
      <%= name %>: (world, state, machine, registers<%= attrs[:argnames].map { |a| ", #{a}" }.join %>) => {
        <%= attrs[:body] %>
      },

    <%- end -%>
  }



Instructions
============

setInt(register, initialValue)
  registers[register] = initialValue

add(register, quantity)
  if(typeof quantity !== 'number')
    throw(new Error(`Not a numeber! ${quantity}`))
  registers[register] += quantity

eq(toRegister, left, right)
  registers[toRegister] = (registers[left] == registers[right])

getKey(toRegister, hashRegister, key)
  if(key[0] === '@') key = registers[key]
  let register = registers[hashRegister][key]
  registers[toRegister] = register

globalToRegister(globalName, registerName)
  if(world[globalName] == undefined) throw(new Error(`No global ${globalName} in globalToRegister`))
  registers[registerName] = world[globalName]

jumpTo(label)
  state.instructionPointer = state.definition.labels[label]

jumpToIf(label, conditionRegister)
  if(registers[conditionRegister])
    state.instructionPointer = state.definition.labels[label]

label(name)
  /* noop */

registerToGlobal(registerName, globalName)
  let value = registers[registerName]
  world[globalName] = value

registerToRegister(from, to)
  registers[to] = registers[from]

setKey(hashRegister, key, valueRegister)
  if(key[0] === '@') key = registers[key]
  registers[hashRegister][key] = registers[valueRegister]

becomeMachine(path)
  // Note: parent is only necessary for popping, as we don't retain a real stack.
  let newMachine = _newMachine(world.$rootMachine, path, registers, state.parent)

  newMachine.definition.arg_names.forEach((argName) => {
    if(!registers[argName])
      throw(new Error(`Expected register ${argName}, but only had: ${inspect(Object.keys(registers))}`))
    newMachine.registers[argName] = registers[argName]
  })
  world.$machineStack = newMachine

runMachine(path, argNames)
  let newMachine = _newMachine(world.$rootMachine, path, registers, state)
  let args = argNames.map((name) => registers[name])

  let l1 = args.length,
      l2 = newMachine.definition.arg_names.length
  if(l1 != l2) throw(new Error(`LENGTHS DO NOT MATCH! expected:${l2}, actual:${l1}`))

  newMachine.definition.arg_names.forEach((argName, index) => {
    newMachine.registers[argName] = args[index]
  })

  world.$machineStack = newMachine

newHash(register)
  registers[register] = {}

aryAppend(aryRegister, toAppendRegister)
  registers[aryRegister].push(registers[toAppendRegister])
