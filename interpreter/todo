Interpreter:
  create Stack class: (#push(val:T):T, #pop():T, #current:T, length:Int, isEmpty:Bool)

Haxe
  Check out guards for pattern matching
  Check empty expression list. It should return nil, pretty sure this returns whatever happens to be the current expression

test showing that I can set a local in toplevel binding, and then access it (ie interpreter is setting up the stack correctly)

-----

Binding class

abstraction in world for constant lookup (world.toplevelNamespace.constants['A'])
abstraction in world for class creation

Binary to organize haxe notes
  jhx, uses cln stuff + useful other binary stuff probably
  jhx repl -> haxelib run ihx

LanguageGoBag
  Map#length
  Map#fetch

Objects
  lazily make the maps (e.g. constants can be null until we need to use it)

consolidate all objects into one file

How cool would it be if we could define the methods with native code within them? e.g.
  class Binding
    native_def local_variable_set(name, val)
      return binding.self.lvars[args['name']] = args['val'];
    end
  end

  class Class
    native_def allocate
      var instance:RObject = {
        klass:binding.self,
        ivars:new ruby.ds.InternalMap(),
      }
      world.objectSpace.push(instance);
      return instance;
    end
  end
  Might be able to edit the parser to accomplish this!
  To deal with the interpretation, we would have to parse it separately and generate the file it goes into.
