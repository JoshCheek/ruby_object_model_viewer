Data Structure:
  constant namespace (pointer to Object)
  Class
    superclass pointer | VALUE
    method table       | {symbol: method}
    ivar table         | {symbol: VALUE}
    name               | String
    class pointer      | VALUE
    constants          | [VALUE]
  object space | [Object]
  Object
    class pointer | VALUE
    ivar table    | {symbol: VALUE}
  TOPLEVEL_BINDING | Stackframe
  Stackframe
    return location  | (??)
    env              | Binding
  Binding
    self            | VALUE
    local var table | {symbol: VALUE}

bytecodes:
  # instances
  allocate(class)                    | Object
  instance_variable_set(name, value) | Object
  instance_variable_get(name)        | Object

  # classes
  create_class(superclass) | Class
  method_set(name, method) | name (Symbol)

  # methods
  create_binding
  create_stackframe
  set_self


Bootstrapping
  once it's sufficiently competent
  could have it parse
    racc   http://rubygems.org/gems/racc
    parser http://rubygems.org/gems/parser
    ast    http://rubygems.org/gems/ast
  and provide these each as a single gemname.ast.json file
  which it could then evaluate (assuming none of them require dynamic parsing, themselves)
  then it would have the ability to parse code without needing to call to the server / invoke the binary

  What all goes into a file system?
    if we can mock the file system, ie FakeFS, then we could straight ship gems and stdlib/core as Ruby files
    if we can do this sufficiently, we can provide a truly matrixed environment, such that most gems and such will have no idea and just work

5.8e+07 <-- make sure ruby parser thing can handle this (for object model)
integrate with moi (prob rename that, since everyone gets it suggested to them, apparently)
subscription types:
  make content that is served by us
  make content that is powered by us but branded with your stuffs - probably based on how many people your content reaches
  we have our own product powered by it, subscription to that product
  some sort of free product to give back to the community and illustrate the value of the paid product
contribute to the people who made it possible (namely whitequark right now, but could maybe contribute to the rspec team and the rack team. idk, look at what gems we're using)
figure out how to deal with ownership / licensing / money
if it makes a sufficient amount of money
  I'll hire someone to perform my teaching responsibilities
  I'll work on whatever I feel is important
  Sometimes this will be teaching, sometimes oss, sometimes this
  w/e it is that I am compelled to do
places to grow:
  if the interpreter got sufficiently capable, we could use it as an in-browser alternative to Opal (since Opal only has one instance... a pretty serious design flaw, imo)
  can integrate with SiB. Instead of Open3, we just instantiate a new Ruby Interpreter and run it that way
  Can evaluate code, then, on the client-side instead of needing to ship it up to the server and send it to eval.in
  Add games:
    The self game
    Where will Ruby go next?
Competencies
  Reasonable rendering
  Reasonable navigating (e.g. granularity, show me only code executing in my file, etc)
  Saving a user's files
  A local version so the user can see across files and such
  Ability to display in the code editor what the browser is currently interpreting
  This is nuts, but Rails integration so that we can use it after the first 6 weeks
  Fake file system so we can use it in SalesEngine
  Lessons that make use of it :P

List of Rubinius bytecodes
  http://rubini.us/doc/en/virtual-machine/instructions/

Ruby Ast to html
  read in an ast
  spit out an html diagram of how the code gets parsed

Group reading a book about game development (JEG)
  hoping to use some of these ideas to make this fun for students to work in
  https://groups.google.com/forum/#!topic/game-maker-study-group/TwGr9AQ_eQk

User experience
  https://en.wikipedia.org/wiki/Seven_stages_of_action
    The 7 stages of action
  http://drhaswell.com/index.php/2012/08/book-review-the-design-of-everyday-things/
    Short summary of best points in the Design of Every Day Things

----- Some inspiration from other tools -----
Holy shit, this doesn't even sound all that hard!
  http://www.lambdacs.com/debugger/
Great article with lots of links and ideas, from the authors of light-table. Haven't read it all or anything.
  http://lighttable.com/2014/05/16/pain-we-forgot/
Not sure, but looks like it has some interesting philisophical implications regarding how we think about software (ie thinking of it not as an app or machine)
  http://pchiusano.blogspot.com/2013/05/the-future-of-software-end-of-apps-and.html
UX for Bing search -- what ideas can we steal?
  http://blogs.msdn.com/b/visualstudio/archive/2014/02/17/introducing-bing-code-search-for-c.aspx
Example Centric programming
  http://www.subtext-lang.org/OOPSLA04.pdf
Omniscient debugging
  http://www.lambdacs.com/debugger/
Debug mode is the only mode -- discusses Bret Victor, some good looking links
  http://gbracha.blogspot.com/2012/11/debug-mode-is-only-mode.html
Local state is harmful -- haven't figured out its point, but I imagine this conclusion is  drawn from a deeper principle
  http://scattered-thoughts.net/blog/2014/02/17/local-state-is-harmful/
Wolfram Deployment API -- apparently they are doing crazy cool shit, worth checking out to get ideas... and possibly use, if it's as awesome as people imply with their hype
  https://www.wolfram.com/universal-deployment-system/
Great talk by Ryan Davis about buliding an interpreter (30 min)
  http://www.confreaks.com/videos/2685-gogaruco2013-let-s-write-an-interpreter
Talk about parsing expressions in Ruby -- Recommended by Ryan Davis in the above talk
  http://confreaks.com/videos/582
Talk about type inferrence (possibly dealing with Soft Typing) by Loren Segal, he recommended it at RubyConf 2014
  https://www.youtube.com/watch?v=AHAONhPchKA
Javascript programming game
  http://alexnisnevich.github.io/untrusted/
